<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Solitaire</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0e1117;
  --felt: #0d2b1a;
  --border: rgba(255,255,255,0.07);
  --gold: #d4a853;
  --gold2: #e8c27a;
  --card-w: 88px;
  --card-h: 124px;
  --card-r: 9px;
  --gap: 14px;
  --white: #f5f0e8;
  --red: #c0392b;
  --black: #1c1c1c;
  --back1: #1a3a7a;
  --back2: #0e2456;
}

body {
  background: var(--bg);
  min-height: 100vh;
  font-family: 'DM Mono', monospace;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 28px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.logo {
  font-family: 'DM Serif Display', serif;
  font-style: italic;
  font-size: 22px;
  color: var(--gold);
  letter-spacing: 0.02em;
}

.header-btns { display: flex; gap: 10px; }

.btn {
  background: transparent;
  border: 1px solid rgba(212,168,83,0.3);
  color: rgba(212,168,83,0.8);
  font-family: 'DM Mono', monospace;
  font-size: 11px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: 7px 16px;
  cursor: pointer;
  border-radius: 5px;
  transition: all 0.15s;
}
.btn:hover {
  background: rgba(212,168,83,0.1);
  border-color: var(--gold);
  color: var(--gold2);
}

#game-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 22px 20px;
  gap: 18px;
  overflow: hidden;
}

.top-zone {
  display: flex;
  gap: var(--gap);
  align-items: flex-start;
  width: 100%;
  max-width: calc(7 * var(--card-w) + 6 * var(--gap));
}

.spacer { flex: 1; }

.foundation-zone {
  display: flex;
  gap: var(--gap);
}

.tableau-zone {
  display: flex;
  gap: var(--gap);
  align-items: flex-start;
  width: 100%;
  max-width: calc(7 * var(--card-w) + 6 * var(--gap));
}

/* Empty slot placeholder */
.slot {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-r);
  border: 1.5px dashed rgba(212,168,83,0.18);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: rgba(212,168,83,0.18);
  font-size: 22px;
  position: relative;
  cursor: pointer;
  transition: border-color 0.15s, background 0.15s;
}
.slot.droppable {
  border-color: rgba(212,168,83,0.6);
  background: rgba(212,168,83,0.06);
}

/* Tableau columns */
.col {
  width: var(--card-w);
  flex-shrink: 0;
  position: relative;
  min-height: var(--card-h);
}
.col.droppable::after {
  content: '';
  position: absolute;
  top: 0; left: 0;
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-r);
  border: 1.5px dashed rgba(212,168,83,0.6);
  background: rgba(212,168,83,0.04);
  pointer-events: none;
  z-index: 0;
}

/* Cards */
.card {
  width: var(--card-w);
  height: var(--card-h);
  border-radius: var(--card-r);
  position: absolute;
  left: 0;
  cursor: default;
  transition: box-shadow 0.1s;
}

.card.face-down {
  background: linear-gradient(145deg, var(--back1), var(--back2));
  border: 1.5px solid rgba(255,255,255,0.08);
  box-shadow: 0 3px 8px rgba(0,0,0,0.5);
}
.card.face-down::before {
  content: '';
  position: absolute;
  inset: 6px;
  border-radius: 4px;
  border: 1px solid rgba(255,255,255,0.1);
  background:
    repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(255,255,255,0.03) 4px, rgba(255,255,255,0.03) 5px),
    repeating-linear-gradient(-45deg, transparent, transparent 4px, rgba(255,255,255,0.03) 4px, rgba(255,255,255,0.03) 5px);
}

.card.face-up {
  background: var(--white);
  border: 1px solid rgba(0,0,0,0.15);
  box-shadow: 0 4px 12px rgba(0,0,0,0.55), 0 1px 3px rgba(0,0,0,0.3);
}

/* Color is set via data attribute to avoid CSS specificity issues */
.card.face-up[data-color="red"] .card-tl,
.card.face-up[data-color="red"] .card-br,
.card.face-up[data-color="red"] .card-center { color: var(--red); }

.card.face-up[data-color="black"] .card-tl,
.card.face-up[data-color="black"] .card-br,
.card.face-up[data-color="black"] .card-center { color: var(--black); }

.card.draggable { cursor: grab; }
.card.draggable:hover {
  box-shadow: 0 6px 18px rgba(0,0,0,0.65), 0 1px 4px rgba(0,0,0,0.3);
  transform: translateY(-2px);
}

.card-tl, .card-br {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  line-height: 1;
}
.card-tl { top: 6px; left: 8px; }
.card-br { bottom: 6px; right: 8px; transform: rotate(180deg); }

.card-rank {
  font-family: 'DM Serif Display', serif;
  font-size: 17px;
  font-weight: 400;
  letter-spacing: -0.02em;
}
.card-suit-small { font-size: 11px; margin-top: 1px; }

.card-center {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 38px;
  opacity: 0.15;
  pointer-events: none;
}

/* ‚îÄ‚îÄ FLIP ANIMATION ‚îÄ‚îÄ
   The card element starts as face-down, halfway through scaleX it swaps
   to face-up content, then completes the second half of the flip.        */
@keyframes flipReveal {
  0%   { transform: scaleX(1);   }
  45%  { transform: scaleX(0);   }
  55%  { transform: scaleX(0);   }
  100% { transform: scaleX(1);   }
}

/* A wrapper that holds both back and front and does the flip */
.flip-wrapper {
  width: var(--card-w);
  height: var(--card-h);
  position: absolute;
  left: 0;
  transform-style: preserve-3d;
  perspective: 600px;
}
.flip-wrapper .card {
  position: absolute;
  top: 0; left: 0;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  animation: none;
}
.flip-wrapper .card.flip-back  { transform: rotateY(0deg);   }
.flip-wrapper .card.flip-front { transform: rotateY(180deg); }

@keyframes doFlip {
  0%   { transform: rotateY(0deg);   }
  100% { transform: rotateY(180deg); }
}
@keyframes doFlipFront {
  0%   { transform: rotateY(-180deg); }
  100% { transform: rotateY(0deg);    }
}

.flip-wrapper.animating .card.flip-back  { animation: doFlip      0.38s cubic-bezier(0.4,0,0.2,1) forwards; }
.flip-wrapper.animating .card.flip-front { animation: doFlipFront 0.38s cubic-bezier(0.4,0,0.2,1) forwards; }

/* ‚îÄ‚îÄ DEAL ANIMATION ‚îÄ‚îÄ */
@keyframes dealSlide {
  from { transform: translate(var(--dx), var(--dy)) scale(0.85); opacity: 0; }
  to   { transform: translate(0, 0) scale(1); opacity: 1; }
}
.card.dealing {
  animation: dealSlide 0.32s cubic-bezier(0.22,1,0.36,1) forwards;
}

/* ‚îÄ‚îÄ WASTE DRAW ANIMATION ‚îÄ‚îÄ */
@keyframes wasteIn {
  from { transform: translateX(-28px) scale(0.94); opacity: 0.4; }
  to   { transform: translateX(0) scale(1); opacity: 1; }
}
.card.waste-in {
  animation: wasteIn 0.22s cubic-bezier(0.22,1,0.36,1) forwards;
}

/* Drag ghost */
#drag-ghost {
  position: fixed;
  pointer-events: none;
  z-index: 10000;
  display: none;
}
#drag-ghost .card { position: absolute; box-shadow: 0 12px 30px rgba(0,0,0,0.7); }

/* Win overlay */
#win-overlay {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 5000;
  background: rgba(0,0,0,0.75);
  align-items: center;
  justify-content: center;
}
#win-overlay.show { display: flex; }

.win-card {
  background: linear-gradient(160deg, #13261a, #0a1a10);
  border: 1px solid rgba(212,168,83,0.4);
  border-radius: 16px;
  padding: 56px 72px;
  text-align: center;
  box-shadow: 0 0 80px rgba(212,168,83,0.12), 0 40px 60px rgba(0,0,0,0.8);
  animation: popIn 0.45s cubic-bezier(0.34,1.56,0.64,1) forwards;
}
@keyframes popIn {
  from { transform: scale(0.6) translateY(30px); opacity: 0; }
  to   { transform: scale(1) translateY(0); opacity: 1; }
}
.win-emoji { font-size: 56px; margin-bottom: 16px; }
.win-title {
  font-family: 'DM Serif Display', serif;
  font-style: italic;
  font-size: 46px;
  color: var(--gold2);
  margin-bottom: 6px;
}
.win-sub {
  font-size: 12px;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: rgba(212,168,83,0.4);
  margin-bottom: 36px;
}
.win-card .btn { font-size: 12px; padding: 10px 28px; }

.conf {
  position: fixed;
  pointer-events: none;
  z-index: 4999;
  border-radius: 1px;
  animation: confFall linear forwards;
}
@keyframes confFall {
  0%   { transform: translateY(-10px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(105vh) rotate(600deg); opacity: 0; }
}
</style>
</head>
<body>

<header>
  <div class="logo">‚ô† Solitaire</div>
  <div class="header-btns">
    <button class="btn" onclick="undo()">‚Ü© Undo</button>
    <button class="btn" onclick="startGame()">New Game</button>
  </div>
</header>

<div id="game-area">
  <div class="top-zone" id="top-zone">
    <div class="slot" id="stock" onclick="clickStock()">‚Ü∫</div>
    <div class="slot" id="waste" style="cursor:default; overflow:visible;"></div>
    <div class="spacer"></div>
    <div class="foundation-zone">
      <div class="slot" id="f0" data-fi="0">‚ô†</div>
      <div class="slot" id="f1" data-fi="1">‚ô•</div>
      <div class="slot" id="f2" data-fi="2">‚ô¶</div>
      <div class="slot" id="f3" data-fi="3">‚ô£</div>
    </div>
  </div>
  <div class="tableau-zone" id="tableau-zone"></div>
</div>

<div id="drag-ghost"></div>

<div id="win-overlay">
  <div class="win-card">
    <div class="win-emoji">üÉè</div>
    <div class="win-title">You Won!</div>
    <div class="win-sub">Well played</div>
    <button class="btn" onclick="startGame()">Deal Again</button>
  </div>
</div>

<script>
// ‚îÄ‚îÄ‚îÄ SOUND ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// All sounds synthesized via Web Audio API ‚Äî no files needed.
const AudioContext = window.AudioContext || window.webkitAudioContext;
let _actx = null;
function getACtx() {
  if(!_actx) _actx = new AudioContext();
  if(_actx.state === 'suspended') _actx.resume();
  return _actx;
}

// Core: short percussive card thwack
// freq     = fundamental pitch of the body thud
// noiseAmt = how much high noise (crispness)
// dur      = total duration in seconds
// vol      = gain
function playCardSound(freq = 180, noiseAmt = 0.55, dur = 0.08, vol = 0.38) {
  const ctx = getACtx();
  const now = ctx.currentTime;

  // ‚îÄ‚îÄ Tonal body (short sine/triangle thud) ‚îÄ‚îÄ
  const osc = ctx.createOscillator();
  const oscGain = ctx.createGain();
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(freq, now);
  osc.frequency.exponentialRampToValueAtTime(freq * 0.4, now + dur);
  oscGain.gain.setValueAtTime(vol * 0.7, now);
  oscGain.gain.exponentialRampToValueAtTime(0.0001, now + dur * 0.9);
  osc.connect(oscGain);
  oscGain.connect(ctx.destination);
  osc.start(now);
  osc.stop(now + dur);

  // ‚îÄ‚îÄ Noise transient (the crisp "click" component) ‚îÄ‚îÄ
  if(noiseAmt > 0) {
    const bufLen = Math.ceil(ctx.sampleRate * dur);
    const buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for(let i = 0; i < bufLen; i++) data[i] = (Math.random() * 2 - 1);
    const noise = ctx.createBufferSource();
    noise.buffer = buf;

    // High-pass to make it crisp, not bassy
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 1800;
    hp.Q.value = 0.7;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(vol * noiseAmt, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + dur * 0.5);

    noise.connect(hp);
    hp.connect(noiseGain);
    noiseGain.connect(ctx.destination);
    noise.start(now);
    noise.stop(now + dur);
  }
}

// Sound variants
function sndPlace()  { playCardSound(160, 0.45, 0.075, 0.18); } // card placed on pile
function sndFlip()   { playCardSound(220, 0.30, 0.09,  0.12); } // card flip reveal
function sndDraw()   { playCardSound(200, 0.38, 0.065, 0.14); } // draw from stock
function sndDeal(i)  {                                           // deal stagger (quieter)
  setTimeout(() => playCardSound(170 + i*2, 0.32, 0.06, 0.10), i * 55);
}
function sndInvalid(){ playCardSound(110, 0.15, 0.05,  0.07); } // failed drop (subtle)
const SUITS  = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
const RANKS  = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const F_SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£'];

function isRed(s)    { return s === '‚ô•' || s === '‚ô¶'; }
function rankVal(r)  { return RANKS.indexOf(r); }

// ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let stock = [], waste = [], found = [[],[],[],[]], tab = [];
let hist = [];

function deepClone(v) { return JSON.parse(JSON.stringify(v)); }

function pushHistory() {
  hist.push({ stock: deepClone(stock), waste: deepClone(waste), found: deepClone(found), tab: deepClone(tab) });
  if(hist.length > 60) hist.shift();
}

function undo() {
  if(!hist.length) return;
  let s = hist.pop();
  stock = s.stock; waste = s.waste; found = s.found; tab = s.tab;
  render();
}

// ‚îÄ‚îÄ‚îÄ SETUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function buildDeck() {
  let d = [];
  for(let s of SUITS) for(let r of RANKS) d.push({ s, r, up: false });
  for(let i = d.length-1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i+1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}

function startGame() {
  document.getElementById('win-overlay').classList.remove('show');
  document.querySelectorAll('.conf').forEach(e => e.remove());
  hist = [];
  let deck = buildDeck();
  tab = [];
  for(let i = 0; i < 7; i++) {
    let col = [];
    for(let j = 0; j <= i; j++) {
      let c = deck.pop();
      c.up = (j === i);
      col.push(c);
    }
    tab.push(col);
  }
  stock = deck;
  waste = [];
  found = [[],[],[],[]];

  // Mark every tableau card for deal animation + sound
  animDeal.clear(); animFlip.clear(); animWaste = false;
  let dealIdx = 0;
  for(let ci = 0; ci < 7; ci++)
    for(let ri = 0; ri < tab[ci].length; ri++) {
      animDeal.add(ci + ':' + ri);
      sndDeal(dealIdx++);
    }

  render();
}

// ‚îÄ‚îÄ‚îÄ RULES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function canStack(card, target) {
  // Place card on target in tableau
  if(!target) return card.r === 'K';
  if(!target.up) return false;
  return isRed(card.s) !== isRed(target.s) && rankVal(card.r) === rankVal(target.r) - 1;
}

function canFoundation(card, fi) {
  let pile = found[fi];
  if(pile.length === 0) return card.r === 'A';
  let top = pile[pile.length - 1];
  return card.s === top.s && rankVal(card.r) === rankVal(top.r) + 1;
}

function bestFoundation(card) {
  for(let i = 0; i < 4; i++) if(canFoundation(card, i)) return i;
  return -1;
}

// ‚îÄ‚îÄ‚îÄ STOCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function clickStock() {
  pushHistory();
  animWaste = false;
  if(stock.length === 0) {
    stock = waste.slice().reverse().map(c => ({ ...c, up: false }));
    waste = [];
    sndDraw();
  } else {
    let c = stock.pop();
    c.up = true;
    waste.push(c);
    animWaste = true;
    sndDraw();
  }
  render();
}

// ‚îÄ‚îÄ‚îÄ MOVE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function doMove(src, srcCi, srcRi, cards, dst, dstIdx) {
  animFlip.clear(); animDeal.clear(); animWaste = false;

  // Remove cards from source
  if(src === 'waste') {
    waste.pop();
  } else {
    tab[srcCi].splice(srcRi);
  }
  // Flip newly exposed tableau card ‚Äî mark it for flip animation
  let willFlip = false;
  if(src === 'tab' && tab[srcCi].length > 0) {
    let newTop = tab[srcCi][tab[srcCi].length - 1];
    if(!newTop.up) {
      newTop.up = true;
      animFlip.add(srcCi + ':' + (tab[srcCi].length - 1));
      willFlip = true;
    }
  }
  // Place at destination
  if(dst === 'found') {
    found[dstIdx].push(cards[0]);
  } else {
    tab[dstIdx].push(...cards);
  }

  sndPlace();
  if(willFlip) setTimeout(sndFlip, 120);

  render();
  if(checkWin()) setTimeout(showWin, 350);
}

function autoMove(src, ci, ri) {
  let pile;
  if(src === 'waste') pile = [waste[ri]];
  else pile = tab[ci].slice(ri);

  // Try foundation if single card
  if(pile.length === 1) {
    let fi = bestFoundation(pile[0]);
    if(fi >= 0) { pushHistory(); doMove(src, ci, ri, pile, 'found', fi); return; }
  }
  // Try tableau
  for(let tci = 0; tci < 7; tci++) {
    if(src === 'tab' && tci === ci) continue;
    let topCard = tab[tci].length > 0 ? tab[tci][tab[tci].length - 1] : null;
    if(canStack(pile[0], topCard)) {
      pushHistory(); doMove(src, ci, ri, pile, 'tab', tci); return;
    }
  }
}

// ‚îÄ‚îÄ‚îÄ WIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function checkWin() { return found.every(f => f.length === 13); }

function showWin() {
  document.getElementById('win-overlay').classList.add('show');
  let colors = ['#d4a853','#e8c27a','#ffffff','#c0392b','#1a3a7a','#2ecc71'];
  for(let i = 0; i < 100; i++) {
    setTimeout(() => {
      let el = document.createElement('div');
      el.className = 'conf';
      el.style.left = Math.random()*100 + 'vw';
      el.style.background = colors[Math.floor(Math.random()*colors.length)];
      let sz = 6 + Math.random()*7;
      el.style.width = sz + 'px';
      el.style.height = sz + 'px';
      el.style.animationDuration = (2 + Math.random()*3) + 's';
      el.style.animationDelay = (Math.random()*0.5) + 's';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 6000);
    }, i * 40);
  }
}

// ‚îÄ‚îÄ‚îÄ CARD DOM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function makeCard(card) {
  let el = document.createElement('div');
  if(!card.up) {
    el.className = 'card face-down';
  } else {
    let color = isRed(card.s) ? 'red' : 'black';
    el.className = 'card face-up';
    el.dataset.color = color;
    el.innerHTML = `
      <div class="card-tl">
        <div class="card-rank">${card.r}</div>
        <div class="card-suit-small">${card.s}</div>
      </div>
      <div class="card-center">${card.s}</div>
      <div class="card-br">
        <div class="card-rank">${card.r}</div>
        <div class="card-suit-small">${card.s}</div>
      </div>`;
  }
  return el;
}

// ‚îÄ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function render() {
  renderStock();
  renderWaste();
  renderFoundations();
  renderTableau();
}

function renderStock() {
  let el = document.getElementById('stock');
  el.innerHTML = '';
  if(stock.length > 0) {
    let c = makeCard({ up: false });
    c.style.position = 'relative';
    c.style.cursor = 'pointer';
    el.appendChild(c);
  } else {
    el.innerHTML = '<span style="opacity:.22;font-size:26px">‚Ü∫</span>';
  }
}

function renderWaste() {
  let el = document.getElementById('waste');
  el.innerHTML = '';
  if(waste.length === 0) { animWaste = false; return; }
  let show = waste.slice(-3);
  show.forEach((card, idx) => {
    let c = makeCard(card);
    c.style.position = 'absolute';
    c.style.left = (idx * 18) + 'px';
    c.style.top = '0';
    c.style.zIndex = idx + 1;
    // Animate only the newly drawn top card
    if(animWaste && idx === show.length - 1) {
      c.classList.add('waste-in');
    }
    if(idx === show.length - 1) {
      c.classList.add('draggable');
      let wi = waste.length - 1;
      attachDrag(c, 'waste', null, wi);
      c.addEventListener('dblclick', e => { e.stopPropagation(); autoMove('waste', null, wi); });
    }
    el.appendChild(c);
  });
  animWaste = false;
}

function renderFoundations() {
  for(let i = 0; i < 4; i++) {
    let el = document.getElementById('f'+i);
    el.innerHTML = '';
    let pile = found[i];
    if(pile.length > 0) {
      let top = pile[pile.length - 1];
      let c = makeCard(top);
      c.style.position = 'relative';
      c.style.display = 'block';
      el.appendChild(c);
    } else {
      el.textContent = F_SUITS[i];
    }
  }
}

function cardTop(cards, idx) {
  let y = 0;
  for(let i = 0; i < idx; i++) y += cards[i].up ? 30 : 20;
  return y;
}

function colHeight(cards) {
  if(cards.length === 0) return 124;
  return cardTop(cards, cards.length - 1) + 124;
}

function renderTableau() {
  let zone = document.getElementById('tableau-zone');
  // Compute stock slot position for deal animation origin
  let stockRect = document.getElementById('stock').getBoundingClientRect();
  let zoneRect  = zone.getBoundingClientRect();

  zone.innerHTML = '';
  for(let ci = 0; ci < 7; ci++) {
    let col = document.createElement('div');
    col.className = 'col';
    col.dataset.ci = ci;
    let cards = tab[ci];
    col.style.height = Math.max(124, colHeight(cards)) + 'px';

    cards.forEach((card, ri) => {
      let key = ci + ':' + ri;

      if(animFlip.has(key)) {
        // Build a flip wrapper with back + front card
        let wrapper = document.createElement('div');
        wrapper.className = 'flip-wrapper';
        wrapper.style.top = cardTop(cards, ri) + 'px';
        wrapper.style.zIndex = ri + 1;

        let back = document.createElement('div');
        back.className = 'card face-down flip-back';

        let front = makeCard(card); // face-up
        front.classList.add('flip-front');
        front.style.position = 'absolute';
        front.style.top = '0'; front.style.left = '0';

        wrapper.appendChild(back);
        wrapper.appendChild(front);
        col.appendChild(wrapper);

        // Trigger animation on next frame
        requestAnimationFrame(() => {
          requestAnimationFrame(() => wrapper.classList.add('animating'));
        });

        // After animation ends, replace wrapper with a plain card
        wrapper.addEventListener('animationend', () => {
          let plain = makeCard(card);
          plain.style.top  = wrapper.style.top;
          plain.style.zIndex = ri + 1;
          if(card.up) {
            plain.classList.add('draggable');
            attachDrag(plain, 'tab', ci, ri);
            plain.addEventListener('dblclick', e => { e.stopPropagation(); autoMove('tab', ci, ri); });
          }
          wrapper.replaceWith(plain);
        }, { once: true });

      } else {
        let c = makeCard(card);
        c.style.top = cardTop(cards, ri) + 'px';
        c.style.zIndex = ri + 1;

        if(animDeal.has(key)) {
          // Calculate offset from stock position to card's final position
          let colLeft = zoneRect.left + ci * (88 + 14);
          let cardTopPx = zoneRect.top + cardTop(cards, ri);
          let dx = stockRect.left - colLeft;
          let dy = stockRect.top  - cardTopPx;
          c.style.setProperty('--dx', dx + 'px');
          c.style.setProperty('--dy', dy + 'px');
          // Stagger: deal column by column, row by row
          let delay = (ci * 3 + ri) * 55;
          c.style.animationDelay = delay + 'ms';
          c.classList.add('dealing');
        }

        if(card.up) {
          c.classList.add('draggable');
          attachDrag(c, 'tab', ci, ri);
          c.addEventListener('dblclick', e => { e.stopPropagation(); autoMove('tab', ci, ri); });
        }
        col.appendChild(c);
      }
    });
    zone.appendChild(col);
  }
  animFlip.clear();
  animDeal.clear();
}

// ‚îÄ‚îÄ‚îÄ ANIMATION STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Set of "col:row" keys that should animate as newly flipped
let animFlip = new Set();
// Set of "col:row" keys that should deal-animate (col=-1 means waste)
let animDeal = new Set();
// Whether the next waste render should animate the top card
let animWaste = false;

// ‚îÄ‚îÄ‚îÄ DRAG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let drag = null;

function attachDrag(el, src, ci, ri) {
  el.addEventListener('mousedown', e => {
    if(e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    let cards;
    if(src === 'waste') cards = [waste[ri]];
    else cards = tab[ci].slice(ri);
    beginDrag(e, src, ci, ri, cards, el);
  });
}

function beginDrag(e, src, ci, ri, cards, origEl) {
  let ghost = document.getElementById('drag-ghost');
  ghost.innerHTML = '';
  ghost.style.display = 'block';
  ghost.style.width = '88px';
  ghost.style.height = (cards.length > 1 ? colHeight(cards) : 124) + 'px';

  cards.forEach((card, i) => {
    let c = makeCard(card);
    c.style.top = (i * 30) + 'px';
    c.style.left = '0';
    ghost.appendChild(c);
  });

  let rect = origEl.getBoundingClientRect();
  drag = { src, ci, ri, cards, offX: e.clientX - rect.left, offY: e.clientY - rect.top };
  posGhost(e.clientX, e.clientY);

  // Hide the dragged card elements in-place so the source looks empty
  // We collect all card elements from the drag start index onward
  if(src === 'waste') {
    // Hide the top waste card (the one being dragged)
    let wasteEl = document.getElementById('waste');
    let cardEls = wasteEl.querySelectorAll('.card');
    // The last one is the dragged card
    if(cardEls.length > 0) cardEls[cardEls.length - 1].style.visibility = 'hidden';
    drag.hiddenEls = [cardEls[cardEls.length - 1]];
  } else {
    // Hide all card elements from ri onward in this column
    let cols = document.querySelectorAll('.col');
    let col = cols[ci];
    let cardEls = col.querySelectorAll('.card');
    let toHide = [];
    for(let i = ri; i < cardEls.length; i++) {
      cardEls[i].style.visibility = 'hidden';
      toHide.push(cardEls[i]);
    }
    drag.hiddenEls = toHide;
  }

  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
}

function posGhost(x, y) {
  let g = document.getElementById('drag-ghost');
  g.style.left = (x - drag.offX) + 'px';
  g.style.top  = (y - drag.offY) + 'px';
}

function onMove(e) {
  if(!drag) return;
  posGhost(e.clientX, e.clientY);
  hilite(e.clientX, e.clientY);
}

function onUp(e) {
  if(!drag) return;
  window.removeEventListener('mousemove', onMove);
  window.removeEventListener('mouseup', onUp);
  document.getElementById('drag-ghost').style.display = 'none';
  clearHilite();

  let t = hitTest(e.clientX, e.clientY);
  if(t) {
    let ok = false;
    if(t.type === 'found') {
      ok = drag.cards.length === 1 && canFoundation(drag.cards[0], t.idx);
    } else {
      let topCard = tab[t.idx].length > 0 ? tab[t.idx][tab[t.idx].length - 1] : null;
      ok = canStack(drag.cards[0], topCard);
    }
    if(ok) {
      pushHistory();
      // doMove calls render() which rebuilds DOM cleanly ‚Äî no need to restore hidden els
      doMove(drag.src, drag.ci, drag.ri, drag.cards, t.type, t.idx);
      drag = null;
      return;
    }
  }
  // Failed drop ‚Äî snap cards back by restoring visibility
  if(drag.hiddenEls) drag.hiddenEls.forEach(el => { el.style.visibility = ''; });
  sndInvalid();
  drag = null;
}

function hitTest(x, y) {
  // Foundations
  for(let i = 0; i < 4; i++) {
    let r = document.getElementById('f'+i).getBoundingClientRect();
    if(x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return { type:'found', idx:i };
  }
  // Tableau
  let cols = document.querySelectorAll('.col');
  for(let col of cols) {
    let r = col.getBoundingClientRect();
    if(x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return { type:'tab', idx: parseInt(col.dataset.ci) };
  }
  return null;
}

function hilite(x, y) {
  clearHilite();
  let t = hitTest(x, y);
  if(!t) return;
  let ok = false;
  if(t.type === 'found') {
    ok = drag.cards.length === 1 && canFoundation(drag.cards[0], t.idx);
    if(ok) document.getElementById('f'+t.idx).classList.add('droppable');
  } else {
    let topCard = tab[t.idx].length > 0 ? tab[t.idx][tab[t.idx].length - 1] : null;
    ok = canStack(drag.cards[0], topCard);
    if(ok) document.querySelectorAll('.col')[t.idx].classList.add('droppable');
  }
}

function clearHilite() {
  document.querySelectorAll('.droppable').forEach(el => el.classList.remove('droppable'));
}

// ‚îÄ‚îÄ‚îÄ GO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
startGame();
</script>
</body>
</html>
